# GHWT 実装ガイドライン

**Date**: 2025-06-01  
Version 1.0 — 2025-06-01

## 概要

本ドキュメントは GHWT (Git Worktree Tool) の実装ガイドラインを定義し、AI駆動開発における一貫性のあるコード品質とメンテナビリティを確保する。
エラーハンドリング戦略、コード品質基準、パフォーマンス最適化の指針を提供し、堅牢で効率的なソフトウェアの実現を目指す。

## 関連ドキュメント

- [test-strategy.md](test-strategy.md) - テスト戦略
- [../003-specifications/cli-interface.md](../003-specifications/cli-interface.md) - CLI インターフェース仕様
- [../003-specifications/filesystem-layout.md](../003-specifications/filesystem-layout.md) - ファイルシステムレイアウト仕様
- [../002-requirements/requirements-ja.md](../002-requirements/requirements-ja.md) - 基本要件

## 変更履歴

| 日付 | バージョン | 変更内容 |
|------|------------|----------|
| 2025-06-01 | 1.0 | 初版作成（AI駆動開発対応） |

---

## 1. エラーハンドリング戦略

### 1.1 エラー分類と対応方針

| エラー分類 | 説明 | 復旧可能性 | 対応方針 |
|-----------|------|-----------|----------|
| **ユーザーエラー** | 無効な引数・オプション | 可能 | 明確なエラーメッセージと修正方法の提示 |
| **システムエラー** | ファイル権限・ディスク容量不足 | 部分的 | 具体的な原因と解決策の提示 |
| **ネットワークエラー** | 接続失敗・タイムアウト | 可能 | リトライ機能と代替手段の提案 |
| **Git操作エラー** | 不正なリポジトリ状態 | 部分的 | Git状態の診断と修復手順の提示 |
| **内部エラー** | プログラムロジックの問題 | 不可能 | 詳細なログ出力とバグレポート誘導 |

### 1.2 エラーハンドリングパターン

**基本的なエラー型定義:**
```rust
pub type Result<T> = std::result::Result<T, GhwtError>;

#[derive(Debug, thiserror::Error)]
pub enum GhwtError {
    #[error("Invalid Git URL: {url}")]
    InvalidUrl { url: String },
    
    #[error("Repository already exists at {path}")]
    RepositoryExists { path: PathBuf },
    
    #[error("Network error: {message}")]
    NetworkError { message: String },
    
    #[error("Git operation failed: {message}")]
    GitError { message: String },
    
    #[error("Permission denied: {path}")]
    PermissionDenied { path: PathBuf },
    
    #[error("Insufficient disk space")]
    InsufficientSpace,
}
```

### 1.3 ユーザーフレンドリーなエラーメッセージ

**エラーメッセージ設計原則:**

**明確性:**
- 何が起こったかを明確に説明
- 技術的詳細は適度に抑制
- ユーザーが理解しやすい言葉を使用

**実用性:**
- 具体的な解決策を提示
- 次に取るべきアクションを明示
- 関連するドキュメントへの参照

**一貫性:**
- 同じ種類のエラーは同じ形式
- 色分けやフォーマットの統一
- 終了コードの一貫した使用

### 1.4 ログ戦略

| レベル | 用途 | 出力条件 | 内容例 |
|--------|------|----------|--------|
| **ERROR** | 致命的エラー | 常時 | 操作失敗、システムエラー |
| **WARN** | 警告・注意 | 常時 | 非推奨機能使用、潜在的問題 |
| **INFO** | 一般情報 | デフォルト | 操作開始・完了、進捗状況 |
| **DEBUG** | デバッグ情報 | --verbose | 詳細な処理フロー、変数値 |
| **TRACE** | 詳細トレース | 開発時のみ | 関数呼び出し、内部状態 |

---

## 2. コード品質基準

### 2.1 命名規則

#### 2.1.1 基本原則

**明確性優先:**
- 略語よりも完全な単語を使用
- 文脈から意味が明確に理解できる
- 一般的でない専門用語は避ける

**一貫性:**
- プロジェクト全体で統一されたパターン
- Rustの慣例に従う
- 既存のエコシステムとの整合性

#### 2.1.2 命名パターン

| 要素 | パターン | 例 |
|------|----------|-----|
| **関数** | `snake_case` | `create_worktree`, `validate_git_url` |
| **構造体** | `PascalCase` | `GitRepository`, `WorktreeConfig` |
| **列挙型** | `PascalCase` | `CommandType`, `ErrorKind` |
| **定数** | `SCREAMING_SNAKE_CASE` | `DEFAULT_BRANCH`, `MAX_RETRY_COUNT` |
| **モジュール** | `snake_case` | `git_operations`, `filesystem_utils` |

### 2.2 ドキュメント記述基準

**関数ドキュメントの必須要素:**
- 機能の概要説明
- 引数の説明（型と用途）
- 戻り値の説明
- エラー条件の明示
- 使用例（必要に応じて）

**モジュールドキュメントの必須要素:**
- モジュールの目的と責務
- 主要な機能の概要
- 使用方法の基本例
- 関連モジュールとの関係

### 2.3 リファクタリング指針

#### 2.3.1 コード重複の排除

**共通処理の抽出:**
- 同じロジックが3回以上出現したら関数化
- エラーハンドリングパターンの統一
- 設定値・定数の一元管理

#### 2.3.2 関数の責務分離

**単一責務原則の適用:**
- 1つの関数は1つの責務のみ
- 関数名から機能が明確に理解できる
- 引数は5個以下に抑制
- 関数の長さは50行以下を目安

---

## 3. パフォーマンス考慮事項

### 3.1 メモリ管理

#### 3.1.1 効率的なメモリ使用

**文字列処理の最適化:**
- 不要な文字列コピーを避ける
- `Cow<str>`型の活用
- 参照の積極的な使用

**大きなデータの処理:**
- ストリーミング処理でメモリ使用量を抑制
- イテレータの活用
- 一度に全データをメモリに読み込まない

#### 3.1.2 リソース管理

**RAII パターンの活用:**
- リソースの自動解放
- `Drop`トレイトの適切な実装
- スコープベースのリソース管理

### 3.2 ファイルI/O最適化

#### 3.2.1 効率的なファイル操作

**バッファリングの活用:**
- `BufReader`/`BufWriter`の使用
- 適切なバッファサイズの設定
- 明示的なフラッシュ

**並行ファイル操作:**
- `rayon`を使用した並行処理
- I/Oバウンドな処理の並行化
- 適切な並行度の設定

#### 3.2.2 ディスク容量の監視

**容量チェック:**
- 操作前の事前チェック
- プラットフォーム固有の実装
- 適切なエラーハンドリング

### 3.3 並行処理

#### 3.3.1 安全な並行処理

**データ競合の回避:**
- `Arc<Mutex<T>>`の適切な使用
- デッドロックの回避
- 最小限のロック範囲

**非同期処理の活用:**
- I/Oバウンドな処理の非同期化
- `tokio`の適切な使用
- エラーハンドリングの統一

---

## 4. セキュリティ考慮事項

### 4.1 入力検証

#### 4.1.1 URL検証

**検証項目:**
- URL形式の妥当性
- 許可されたスキーム（https, http, ssh）
- 危険な文字の除去
- 長さ制限の適用

#### 4.1.2 パス検証

**検証項目:**
- パストラバーサル攻撃の防止
- システムディレクトリへのアクセス制限
- 絶対パスへの正規化
- 権限の事前確認

### 4.2 権限管理

#### 4.2.1 最小権限の原則

**ファイル権限:**
- 所有者のみアクセス可能（700/600）
- 不要な権限の付与を避ける
- プラットフォーム固有の権限設定

**プロセス権限:**
- 必要最小限の権限で実行
- 特権昇格の回避
- 安全なデフォルト設定

---

## 5. デバッグ・トラブルシューティング

### 5.1 デバッグ支援機能

#### 5.1.1 詳細ログ出力

**ログ出力方針:**
- 操作の開始・終了をログ出力
- エラー発生時の詳細な状況記録
- デバッグ時の内部状態出力
- 個人情報の除去

#### 5.1.2 環境情報の収集

**収集対象:**
- システム情報（OS、アーキテクチャ）
- Git情報（バージョン、設定）
- 環境変数（GHQ_ROOT等）
- ディスク容量・権限情報

### 5.2 自動診断機能

#### 5.2.1 システム状態チェック

**診断項目:**
- Git インストール確認
- ディスク容量確認
- 権限確認
- ネットワーク接続確認

**診断結果:**
- Pass/Warning/Failの3段階評価
- 具体的な問題の説明
- 解決策の提案
- 関連ドキュメントへの参照

---

## 6. AI駆動開発特有の考慮事項

### 6.1 AI実装前の準備

**コード生成の品質向上:**
- 明確な仕様書の作成
- 具体的な期待値の定義
- エラーケースの網羅的な列挙
- 境界値・例外ケースの明示

**実装指針の明確化:**
- コーディング規約の事前定義
- エラーハンドリング方針の明示
- パフォーマンス要件の具体化
- セキュリティ要件の明文化

### 6.2 AI実装中の品質管理

**継続的な品質監視:**
- テスト実行結果の自動監視
- コード品質メトリクスの追跡
- AI生成コードの品質評価
- 人間によるコードレビュー

**フィードバックループの確立:**
- テスト失敗時の迅速な修正
- 品質問題の根本原因分析
- 実装方針の継続的改善
- AI生成コードの学習データ化

---

## 7. まとめ

本実装ガイドラインは、AI駆動開発における一貫性のあるコード品質とメンテナビリティを確保するための指針を提供する。

**重要なポイント:**
- **エラーハンドリング**: ユーザーフレンドリーなメッセージと適切な復旧手順
- **コード品質**: 明確な命名規則と十分なドキュメント
- **パフォーマンス**: 効率的なメモリ・ファイルI/O管理
- **セキュリティ**: 入力検証と最小権限の原則
- **デバッグ支援**: 詳細なログと自動診断機能
- **AI協調**: AI実装に適した明確な仕様と品質管理

これらの指針に従うことで、堅牢で効率的、かつメンテナブルなGHWTツールの実装が可能となる。 